/*
 * AFSK Modulator/Transmitter
 */
 
#include "config.h"
#include <avr/io.h>
#include <inttypes.h>
#include <stdlib.h>
#include <avr/interrupt.h>
#include "afsk.h"
#include "kernel.h"
#include "stream.h"

/* Move to config.h or afsk.h */
#define AFSK_TXTONE_MARK  2200
#define AFSK_TXTONE_SPACE 1200

/* Internal config */
#define _PRESCALER0  64
#define _TXI_MARK   ((F_CPU / _PRESCALER0 / AFSK_TXTONE_MARK / 2) - 1 )
#define _TXI_SPACE  ((F_CPU / _PRESCALER0 / AFSK_TXTONE_SPACE / 2) - 1 )


uint8_t  transmit; 		
static stream_t *stream;


   
void init_afsk_TX()
{
   TCCR0B = 0x03           /* Pre-scaler for timer0 = 64 */             
          | (1<<WGM02);    /* CTC mode */             
   TIMSK0 = 1<<OCIE0A;     /* Interrupt on compare match */  
   OCR0A  = _TXI_SPACE;
}		




/*******************************************************************************
 * Turn on transmitter (tone generator, ptt and led.)
 *******************************************************************************/
 
void afsk_ptt_on()
{
//  afsk_disable_RX();
    transmit = TRUE; 
}



/*******************************************************************************
 * Turn off transmitter (tone generator, ptt and led.)
 *******************************************************************************/

void afsk_ptt_off()
{
    transmit = FALSE; 
//  afsk_enable_RX(); 
}



/***********************************************
 * Get next bit from stream
 * Note: see also get_bit() in hdlc_decoder.c 
 ***********************************************/
 
static uint8_t get_bit()
{
  static uint8_t bits;
  static uint8_t bit_count = 0;
  
  if (bit_count == 0) {
    bits = getch (stream);
    bit_count = 8;
  } 
  
  uint8_t bit = bits & 0x01;
  bits >>= 1;
  bit_count--;
  return bit;
}


/*******************************************************************************
 * If transmit flag is on, this function should be called periodically, 
 * at same rate as wanted baud rate.
 *
 * It is responsible for transmitting frames by toggling the frequency of
 * the tone generated by the interrupt handler below. 
 *******************************************************************************/ 
 
void afsk_txBitClock()
{
    register uint8_t bit = get_bit();
    if ( !bit ) {
        /* Toggle TX frequency */
        enter_critical();
        OCR0A = ((OCR0A >= _TXI_MARK) ? _TXI_SPACE : _TXI_MARK); 
        if (TCNT0 > OCR0A)
            TCNT0 = 0xFF - TCNT0;
        leave_critical();
    }
}



/******************************************************************************
 * Simple method of generating a clock signal at 1200 and 2200 Hz. 
 * This is output to ADF TXRXCLK pin. Note: If we can use the OC1A pin  
 * we dont need this interrupt handler at all! 
 ******************************************************************************/
 
SIGNAL(TIMER0_COMPA_vect)
{
     toggle_bit( ADF_SCLK );
} 

 
