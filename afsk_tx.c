/*
 * AFSK Modulator/Transmitter
 */
 
#include "config.h"
#include <avr/io.h>
#include <inttypes.h>
#include <stdlib.h>
#include <avr/interrupt.h>
#include "afsk.h"
#include "kernel.h"
#include "stream.h"

/* Move to config.h or afsk.h */
#define AFSK_TXTONE_MARK  2200
#define AFSK_TXTONE_SPACE 1200

/* Internal config */
#define _PRESCALER0  64
#define _TXI_MARK   ((F_CPU / _PRESCALER0 / AFSK_TXTONE_MARK / 2) - 1 )
#define _TXI_SPACE  ((F_CPU / _PRESCALER0 / AFSK_TXTONE_SPACE / 2) - 1 )


bool     transmit; 		
stream_t afsk_tx_stream;

   
stream_t* afsk_init_encoder() 
{
    STREAM_INIT(afsk_tx_stream, AFSK_ENCODER_BUFFER_SIZE);    
    return &afsk_tx_stream;
}		




/*******************************************************************************
 * Turn on transmitter (tone generator, ptt and led.)
 *******************************************************************************/
 
void afsk_ptt_on()
{
//  should notify application level?

    TCCR0B = 0x03           /* Pre-scaler for timer0 = 64 */             
           | (1<<WGM02);    /* CTC mode */             
    TIMSK0 = 1<<OCIE0A;     /* Interrupt on compare match */ 
    OCR0A  = _TXI_SPACE;
    transmit = TRUE; 
    set_bit(USBKEY_LED4);
}



/*******************************************************************************
 * Turn off transmitter (tone generator, ptt and led.)
 *******************************************************************************/

void afsk_ptt_off()
{
    transmit = FALSE; 
    clear_bit(USBKEY_LED4);
//  should notify application level 
}



/***********************************************
 * Get next bit from stream
 * Note: see also get_bit() in hdlc_decoder.c 
 ***********************************************/
 
static uint8_t get_bit()
{
  static uint8_t bits;
  static uint8_t bit_count = 0;
  
  if (bit_count == 0) 
  {
    /* Turn off TX if buffer is empty (have reached end of frame) */
    if (_stream_empty(&afsk_tx_stream)) {
        afsk_ptt_off();
        return 1; 
    }   
    bits = _stream_get (&afsk_tx_stream, true);
    bit_count = 8;
  } 

  uint8_t bit = bits & 0x01;
  bits >>= 1;
  bit_count--;
  return bit;
}



/*******************************************************************************
 * If transmit flag is on, this function should be called periodically, 
 * at same rate as wanted baud rate.
 *
 * It is responsible for transmitting frames by toggling the frequency of
 * the tone generated by the interrupt handler below. 
 *******************************************************************************/ 
 
void afsk_txBitClock()
{
    if (!transmit) 
        return;
        
    register uint8_t bit = get_bit();
    if ( !bit ) {
        /* Toggle TX frequency */ 
        enter_critical();
        OCR0A = ((OCR0A >= _TXI_MARK) ? _TXI_SPACE : _TXI_MARK); 
        if (TCNT0 > OCR0A)
            TCNT0 = 0xFF - TCNT0;
        leave_critical();
    }
}



/******************************************************************************
 * Simple method of generating a clock signal at 1200 and 2200 Hz. 
 * This is output to ADF TXRXCLK pin. Note: If we can use the OC1A pin  
 * we dont need this interrupt handler at all! 
 ******************************************************************************/
 
ISR(TIMER0_COMPA_vect)
{   
     toggle_bit( ADF_SCLK );
} 

 
