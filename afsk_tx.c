/*
 * AFSK Modulator/Transmitter
 */
 
#include "config.h"
#include <avr/io.h>
#include <inttypes.h>
#include <stdlib.h>
#include <avr/interrupt.h>
#include "afsk.h"
#include "kernel.h"
#include "stream.h"

/* Move to config.h or afsk.h */
#define AFSK_TXTONE_MARK  1200
#define AFSK_TXTONE_SPACE 2200

/* Internal config */
#define _PRESCALER0  8
#define _TXI_MARK   ((SCALED_F_CPU / _PRESCALER0 / AFSK_TXTONE_MARK / 2) - 1)
#define _TXI_SPACE  ((SCALED_F_CPU / _PRESCALER0 / AFSK_TXTONE_SPACE / 2) - 1)


bool     transmit; 		
stream_t afsk_tx_stream;

   
stream_t* afsk_init_encoder(void) 
{
    STREAM_INIT(afsk_tx_stream, AFSK_ENCODER_BUFFER_SIZE);    
    return &afsk_tx_stream;
}		




/*******************************************************************************
 * Turn on transmitter (tone generator, ptt and led.)
 *******************************************************************************/
 
void afsk_ptt_on()
{
//  should notify application level?

    TCCR0B = 0x02;             /* Pre-scaler for timer0 = 8x prescaling */             
    TCCR0A = 0x02;             /* CTC mode */             
    TCCR0A |= (1<<COM0A0);     /* Toggle OC0A on compare match */
    OCR0A  = _TXI_MARK;
    TIMSK0 = 1<<OCIE0A;        /* Interrupt on compare match */ 
    transmit = true; 
    set_bit(USBKEY_LED4);
}



/*******************************************************************************
 * Turn off transmitter (tone generator, ptt and led.)
 *******************************************************************************/

void afsk_ptt_off(void)
{
    TIMSK0 = 0x00;
    TCCR0A &= ~(1<<COM0A0);           /* Toggle OC0A on compare match: OFF */
    transmit = false; 
    clear_bit(USBKEY_LED4);            /* LED / PTT */
    clear_bit(ADF_TXRXDATA);           /* out signal */
//  should notify application level 
}



/***********************************************
 * Get next bit from stream
 * Note: see also get_bit() in hdlc_decoder.c 
 ***********************************************/
 
static uint8_t get_bit(void)
{
  static uint8_t bits;
  static uint8_t bit_count = 0;
  if (bit_count == 0) 
  {
    /* Turn off TX if buffer is empty (have reached end of frame) */
    if (_stream_empty(&afsk_tx_stream)) {
        afsk_ptt_off();
        return 1; 
    }   
    bits = _stream_get (&afsk_tx_stream, true); 
    bit_count = 8;    
  } 
  uint8_t bit = bits & 0x01;
  bits >>= 1;
  bit_count--;
  return bit;
}



/*******************************************************************************
 * If transmit flag is on, this function should be called periodically, 
 * at same rate as wanted baud rate.
 *
 * It is responsible for transmitting frames by toggling the frequency of
 * the tone generated by the interrupt handler below. 
 *******************************************************************************/ 
 
void afsk_txBitClock(void)
{
    if (!transmit) {
        if (_stream_empty(&afsk_tx_stream))
           return;
        else
           afsk_ptt_on();
    }       
    if ( ! get_bit() ) {
        /* Toggle TX frequency */ 
        enter_critical();
        register uint8_t newtop = ((OCR0A >= _TXI_MARK) ? _TXI_SPACE : _TXI_MARK); 
        if (TCNT0 >= newtop)
            TCNT0 = _TXI_MARK - TCNT0 ;
        OCR0A = newtop;
        leave_critical();
    }
}



/******************************************************************************
 * Simple method of generating a clock signal at 1200 and 2200 Hz. 
 * This is output to ADF TXRXCLK pin. Note: If we can use the OC1A pin  
 * we dont need this interrupt handler at all! 
 ******************************************************************************/
 
ISR(TIMER0_COMPA_vect)
{   
     toggle_bit( ADF_TXRXDATA );
} 

 
