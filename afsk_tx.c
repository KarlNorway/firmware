/*
 * AFSK Modulator/Transmitter
 */
 
#include "config.h"
#include <avr/io.h>
#include <inttypes.h>
#include <stdlib.h>
#include <avr/interrupt.h>
#include "fbuf.h"
#include "afsk.h"
#include "kernel.h"
#include "timer.h"
#include "stream.h"


static unsigned char	txtone;		
uint8_t	transmit;		          
uint8_t txbytes; 

// Buffers
FBQ outbuf; 
static FBUF buffer;                                 

#define BUFFER_EMPTY (fbuf_eof(&buffer))            
#define TXTOGGLE txtone = (txtone == MARK)? SPACE : MARK

enum {TXOFF, TXPRE, TXPACKET, TXPOST} txState; 

/* FIXME: Those should be parameters stored in EEPROM ! */
#define TXDELAY 30
#define TXTAIL 4
#define PERSISTENCE 100
#define SLOTTIME    50


static void afsk_ptt_on();
static void afsk_ptt_off();


   
void init_afsk_TX()
{
   DEFINE_FBQ(outbuf, TX_Q_SIZE);
   PORTC = 0x00;
   DDRC = 0x0F;
   
	TCCR1B = 0x02; 		  // Timer2 clock prescale of 8
	afsk_ptt_off();		  // Remove???
   txtone = SPACE;
}		



/*******************************************************************************
 * Transmit a frame.
 *
 * This function gets a frame from buffer-queue, and starts the transmitter
 * as soon as the channel is free. It should typically be called repeatedly
 * from a loop in a thread.  
 *******************************************************************************/
 
void afsk_startTx()
{  
   /* Get frame from buffer-queue when available. This is a blocking call.
    * FIXME: Protect against concurrent access
    */
   buffer = fbq_get(&outbuf);     
       
   /* Wait until channel is free 
    * P-persistence algorithm 
    */
   for (;;) {
     while (dcd)
        t_yield(); 
     int r  = rand(); 
     if (r > PERSISTENCE * 255)
         sleep(SLOTTIME); 
     else
         break;
   }
      
   /* Activate transmitter */  
   txState = TXPRE;
   txbytes = 0;
   afsk_ptt_on();
}
   


/*******************************************************************************
 * Turn on transmitter (tone generator, ptt and led.)
 *******************************************************************************/
 
static void afsk_ptt_on()
{
    afsk_disable_RX();
    transmit = TRUE; 
}



/*******************************************************************************
 * Turn off transmitter (tone generator, ptt and led.)
 *******************************************************************************/

static void afsk_ptt_off()
{
    transmit = FALSE; 
    afsk_enable_RX(); 
}




/*******************************************************************************
 * If transmit flag is on, this function should be called periodically, 
 * at same rate as wanted baud rate.
 *
 * It is responsible for transmitting frames by toggling the frequency of
 * the tone generated by the interrupt handler below. It is responsible for
 * bit stuffing and for adding flags at start and end of frames.
 *******************************************************************************/
 
void afsk_txBitClock()
{
    static uint8_t txbyte, txbits, bit_zero, flag, nflags;  
    static unsigned char sequential_ones;


    /* 
     * This part (if txbits == 0) is run when we are out of bits to 
     * transmit. We determine the next byte to send or alternatively, to
     * turn off the transmitter.
     */  
    if (txbits == 0) 
    {
        /* 
         * State machine: 
         * TXPRE    - start sending frame - send as many flags as indicated in TXDELAY
         * TXPOST   - end frame - send as many flags as indicated in TXTAIL
         * TXPACKET - send frame data until buffer is empty.
         * TXOFF    - turn off the transmitter          
         */
        if (txState == TXPRE && nflags >= TXDELAY)
             txState = TXPACKET;
             
        else if (txState == TXPOST && nflags >= TXTAIL) {
             nflags = 0; 
             txState = TXOFF; 
        }
        else if (txState == TXPACKET && BUFFER_EMPTY) {
             nflags = 0;                               // If end of buffer, go to TXPOST state (send end-of-frame flags)
             txState = TXPOST;                         // FIXME: Allow more than one frame per transmission?
             fbuf_release(&buffer); 
        }    
        
        
        /*
         * Do the work (depending on the state). 
         * Get next byte to transmit, or turn off.
         */
        if (txState == TXOFF) {      
            transmit = FALSE;                          // Turn off transmitter
            return; 
        }    
        else if (txState == TXPACKET) {          
            txbyte = fbuf_getChar(&buffer);            // send next byte from buffer
            txbytes++; 
            flag = 0;        
        }
        else {                                 
            flag = txbyte = FLAG;                      // Send flag. And indicate that this was done deliberately
            nflags++;                                  // And count how many flags was sent  
        }
        txbits = 8; 
    }
    
    
    /* 
     * Transmit the bits. Toggle transmitter tone if 0. Do nothing if 1. 
     * We also do bit-stuffing here. 
     */
    if (flag)
        sequential_ones = 0; 
        
    bit_zero = txbyte & 0x01;  
    if (!bit_zero || sequential_ones++ == 6) 
        sequential_ones = 0;

    if (sequential_ones < 6) 
       { txbyte >>= 1; txbits--; }    
       
    if (!sequential_ones)                       
        TXTOGGLE;
}





#ifdef AFSK_METHOD_ADF

/*
 * Simple method of generating a clock signal at 1200 and 2200 Hz. 
 * This is output to ADF TXRXCLK pin. It is possible to set the hardware
 * to automagically toggle the OC1A pin each time TCNT1 matches OCR1A, 
 * and then we dont need this interrupt handler. 
 */
SIGNAL(SIG_OVERFLOW1)
{
    if (transmit)
    {
       TOGGLE_OUTPUT;
         /* Det er en liten mulighet for at vi mister match-interrupt og
          * og at telleren vil fortsette fra 0. Da vil vi få en lang puls ut, noe
          * vi ikke ønsker. Sannsynligheten for det er imidlertid svært liten. 
          */ 
    }
} 

#define TXTOGGLE { txtone=(txtone==MARK ? SPACE : MARK); OCR1A=txtone; }

 
#else

/*******************************************************************************
 *  Tone generator interrupt routine (based on the whereavr code)
 *
 *  This function handles the counter2 overflow interrupt.
 *	 Counter2 is used to generate a sine wave using resistors on
 *	 Pins B5-B1. Following are the sixteen 4-bit sinewave values:
 *	          7, 10, 13, 14, 15, 14, 13, 10, 8, 5, 2, 1, 0, 1, 2, 5.
 *	 If in receive mode, the counter is pre-loaded with a long delay
 *	 and the delay variable is cleared.
 *******************************************************************************/

SIGNAL(SIG_OVERFLOW1)
{
   static char sine[16] = {14, 5, 11, 7, 15, 7, 11, 5, 1, 10, 4, 8, 0, 8, 4, 10};
	static unsigned char sine_index;		// Index for the D-to-A sequence

	if (transmit)
	{
		++sine_index;							// Increment index
		sine_index &= 15;						// And wrap to a max of 15
		PORTC = sine[sine_index];			// Load next D-to-A sinewave value
		TCNT1 = txtone;						// Preload counter based on freq.
	}
	else
		TCNT1 = 0;								// Make long as possible delay
} 


#endif
