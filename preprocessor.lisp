;;; Preprocessor to extract command (and future parameter)
;;; definitions from C files


(defun skip-char (predicate &optional (stream *standard-input*)
                  (eof-error-p t) eof-value)
  (declare (type (or function symbol) predicate))
  (handler-case
    (loop
     as char = (read-char stream)
     while (funcall predicate char)
     finally (unread-char char stream)
             (return-from skip-char char))
    (end-of-file ()
      (if eof-error-p
          (error 'end-of-file :stream stream)
        (return-from skip-char eof-value)))))

(defun visible-char-p (char)
  (and (graphic-char-p char) (char/= char #\space)))

(defun whitespace-p (char)
  (not (visible-char-p char)))

(defun skip-whitespace (&optional (stream *standard-input*))
  (skip-char #'whitespace-p stream nil))

(defun eof-p (stream)
  (eq (peek-char nil stream nil :eof) :eof))

(defun skip-comment (stream)
  (case (peek-char nil stream)
    (#\/ (read-line stream nil)
	 (skip-whitespace stream)
	 t)
    (#\* (let ((prev #\nul))
	   (skip-char 
	    #'(lambda (char) 
		(prog1
		    (or (char/= prev #\*) (char/= char #\/))
		  (setq prev char)))
	    stream nil)
	 (skip-whitespace stream)
	 t))
    (t nil)))

(defun skip-string (stream)
  (skip-char 
   #'(lambda (char) 
       (prog1
	   (char/= char #\")
	 (when (char= char #\\)
	   (read-char stream))))
   stream)
  (read-char stream))

(defun input-match-p (string &optional (stream *standard-input*)
                      (case-insensitive nil) error-p)
  (map nil
   #'(lambda (char)
       (let ((input-char (read-char stream nil)))
         (unless (or (char= input-char char)
                     (and case-insensitive (char-equal input-char char)))
           (if error-p
               (error "Input did not match ~S" string)
             (return-from input-match-p)))))
   (string string))
  t)

(defun read-string (predicate &optional (stream *standard-input*)
                    (eof-error-p t) eof-value)
  (let ((string  (make-array 0 :element-type 'character 
		  :fill-pointer t :adjustable t)))
    (loop
     (let ((char (read-char stream eof-error-p :eof)))
       (cond
        ((eq char :eof)
         (return (if (zerop (length string)) eof-value string)))
        ((not (funcall predicate char))
         (unread-char char stream)
         (return (values string char)))
        (t (vector-push-extend char string)))))))

(defun split-string (string)
  (let ((pos (position #\sp string)))
    (if pos
	(cons (subseq string 0 pos) (split-string (subseq string (1+ pos))))
      (list string))))

(defun collect-defs (filename)
  (let ((commands ()))
    (with-open-file (input filename :external-format #+sbcl :latin-1 #+clisp charset:iso-8859-1)
      (loop while (progn (skip-whitespace input) (not (eof-p input))) do
        (let ((char (read-char input)))
	  (case char
	    (#\/ (when (peek-char nil input)
		   '(#\* #\/) :test #'char=)
		 (skip-comment input))
	    (#\# (read-line input nil)) ; skipping cpp directive
	    (#\" (skip-string input))
	    (#\' (when (char= (read-char input) #\\)
		   (read-char input))
		 (read-char input))
	    (t
	     (unread-char char input)
	     (when (input-match-p "DEFCMD" input)
	       (skip-whitespace input)
	       (skip-comment input)
	       (input-match-p "(" input nil t)
	       (skip-whitespace input)
	       (skip-comment input)
	       (push (read-string #'alpha-char-p input) commands)))))))
    commands))


(defun gen-c-file (outfile files)
  (with-open-file (output outfile :direction :output :if-exists :supersede)
    (let ((commands 
	   (sort
	    (loop for file in files nconc (collect-defs file))
	    #'string<)))
      (write-line "/* Autogenerated file. Do not edit! */" output)
      (format output "~%#include \"commands.h\"~%#include <avr/pgmspace.h>~%~%")
      (dolist (command commands)
	(format output "extern const command_t PROGMEM __~a_command;~%" command))
      (format output "~%const command_t PROGMEM *commands[] = {")
      (dolist (command commands)
	(format output "&__~a_command, " command))
      (write-line "};" output)
      (format output "~%int num_commands = ~d;~%" (length commands)))))


#+sbcl
(gen-c-file (second *posix-argv*) (cddr *posix-argv*))
#+clisp
(gen-c-file (first ext:*args*) (rest ext:*args*))
